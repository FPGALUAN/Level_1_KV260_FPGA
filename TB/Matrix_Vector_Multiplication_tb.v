/*-----------------------------------------------------------------------------
 * File          : Matrix_Vector_Multiplication_tb.v
 * Author        : Auto-generated by ChatGPT
 * Created       : 05.05.2025
 *-----------------------------------------------------------------------------
 * Description   : Testbench for Matrix_Vector_Multiplication module. 
 *                 Reads input matrix A and vector X from external files and 
 *                 writes the output vector Y to a result file.
 *-----------------------------------------------------------------------------
 */

`timescale 1ns/1ps
`define N_TXT_PATH         "/home/hoailuan/Phat_Trien_Phan_Cung_FPGA/Kria_KV260_FPGA/Level_1/C_Code_MatrixVector/n.txt"
`define MATRIX_A_TXT_PATH  "/home/hoailuan/Phat_Trien_Phan_Cung_FPGA/Kria_KV260_FPGA/Level_1/C_Code_MatrixVector/Matrix_A.txt"
`define VECTOR_X_TXT_PATH  "/home/hoailuan/Phat_Trien_Phan_Cung_FPGA/Kria_KV260_FPGA/Level_1/C_Code_MatrixVector/Vector_X.txt"
`define VECTOR_Y_TXT_PATH  "/home/hoailuan/Phat_Trien_Phan_Cung_FPGA/Kria_KV260_FPGA/Level_1/C_Code_MatrixVector/Vector_Y_Hardware.txt"

module Matrix_Vector_Multiplication_tb;

    parameter DATA_WIDTH = 16;
    parameter W_ADDR_WIDTH = 12;
    parameter R_ADDR_WIDTH = 11;
    parameter MEM_DEPTH = 1 << R_ADDR_WIDTH;

    reg                             CLK;
    reg                             RST;
    reg  [W_ADDR_WIDTH-1:0]         W_Addr_in;
    reg                             W_Valid_in;
    reg  [DATA_WIDTH*8-1:0]         W_Data_in;
    reg  [R_ADDR_WIDTH-1:0]         R_Addr_in;
    reg                             R_Valid_in;
    reg  [R_ADDR_WIDTH-1:0]         n_in;
    reg                             Load_in;
    reg                             Start_in;

    wire                            Done_out;
    wire [DATA_WIDTH*8-1:0]         R_Data_out;

    // Instantiate DUT
    Matrix_Vector_Multiplication uut (
        .CLK(CLK),
        .RST(RST),
        .W_Addr_in(W_Addr_in),
        .W_Valid_in(W_Valid_in),
        .W_Data_in(W_Data_in),
        .R_Addr_in(R_Addr_in),
        .R_Valid_in(R_Valid_in),
        .n_in(n_in),
        .Load_in(Load_in),
        .Start_in(Start_in),
        .Done_out(Done_out),
        .R_Data_out(R_Data_out)
    );

    // Clock generation
    always #5 CLK = ~CLK;

    integer i, j, k, h, f_n, f_matrix, f_vector, f_result;
    integer size, n, WS1, WS2;
    reg signed [15:0] matrix [0:MEM_DEPTH-1][0:MEM_DEPTH-1];
    reg signed [15:0] vector [0:MEM_DEPTH-1];

    initial begin
        CLK 		= 0;
        RST 		= 0;
        W_Valid_in 	= 0;
        R_Valid_in 	= 0;
        Load_in 	= 0;
        Start_in 	= 0;
		W_Addr_in 	= 0;
		R_Addr_in	= 0;
		W_Data_in 	= 0;

        $display("Reading n.txt...");
        f_n = $fopen(`N_TXT_PATH, "r");
        if (!f_n) begin
            $display("ERROR: Cannot open n.txt");
            $finish;
        end
        $fscanf(f_n, "%d", n);
        $fclose(f_n);
		$display("Reading Matrix_A.txt...");
        f_matrix = $fopen(`MATRIX_A_TXT_PATH, "r");
		$display("Reading Vector_X.txt...");
        f_vector = $fopen(`VECTOR_X_TXT_PATH, "r");
        n_in = n;
        size = 1 << n;
		WS1 = (n <= 7) ? 1: (1 << ((n+n) - 14));
		WS2 = (n <= 7) ? size: (1 << (14 - n));
		
        #25 RST = 1;
		#20 Load_in = 1; #10 Load_in = 0;
		
		for (i = 0; i < size; i = i + 1)
			$fscanf(f_vector, "%d", vector[i]);
			
		$display("Writing Vector X to BRAM...");
		
		for (i = 0; i < size; i = i + 8) begin
			W_Data_in = 0;
			for (k = 0; k < 8; k = k + 1) begin
				W_Data_in[DATA_WIDTH*(8-k)-1 -: DATA_WIDTH] = vector[i+k];
			end
			W_Addr_in 	= 12'h800 | (W_Addr_in + W_Valid_in);
			W_Valid_in 	= 1;
			#10;
		end
		
		W_Valid_in 	= 0;
		W_Addr_in 	= 0;
		W_Data_in 	= 0;
		
		#100;
		
		for(h =0; h < WS1; h = h + 1) begin
			for (i = 0; i < WS2; i = i + 1)
				for (j = 0; j < size; j = j + 1)
					$fscanf(f_matrix, "%d", matrix[i][j]);
					
			W_Addr_in = 0;
			$display("Writing Matrix A to BRAM...");
			for (i = 0; i < WS2; i = i + 1) begin
				for (j = 0; j < size; j = j + 8) begin
					W_Data_in = 0;
					for (k = 0; k < 8; k = k + 1) begin
						W_Data_in[DATA_WIDTH*(8-k)-1 -: DATA_WIDTH] = matrix[i][j+k];
					end
					W_Addr_in 	= W_Addr_in + W_Valid_in;
					W_Valid_in 	= 1;
					#10;
				end
			end
			W_Valid_in 	= 0;
			W_Addr_in 	= 0;
			W_Data_in 	= 0;
		
			
			#20 Start_in = 1; #10 Start_in = 0;
			R_Addr_in 	= 0;
			R_Valid_in 	= 0;
			wait (!Done_out);
			wait (Done_out);
			#100;
		end
		#20;
        $display("Reading results from BRAM...");
        f_result = $fopen(`VECTOR_Y_TXT_PATH, "w");
        for (i = 0; i < size; i = i + 8) begin
            R_Addr_in = R_Addr_in + R_Valid_in;
            R_Valid_in = 1;
            #10;
            for (j = 0; j < 8; j = j + 1)
                $fwrite(f_result, "%0d\n", $signed(R_Data_out[DATA_WIDTH*(8-j)-1 -: DATA_WIDTH]));
        end
		R_Addr_in 	= 0;
        R_Valid_in 	= 0;
		$fclose(f_matrix);
		$fclose(f_vector);
        $fclose(f_result);

        $display("Testbench completed. Results written to Vector_Y_Hardware.txt");
        $finish;
    end

endmodule
